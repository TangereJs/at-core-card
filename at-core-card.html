<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="swipe-action.html" />
<link rel="import" href="../at-carbon-icon-color/at-carbon-icon-color.html" />


<!-- 
  //TODO 
  1. how should swipe zie and swipe rubber band values be defined and or forwarded to swipe-action
  2. when left or right action is tapped how is containing element notified of this? events are obvious solution for this
  3. how to modify swipe-action to support action execution when swipe target is dragged above defined threshold
  4. cleanup at-core-card obsolete code and css
 -->

<dom-module id="at-core-card">
    <style>
        :host {
          background-color: #fff;
          border-radius: 2px;
          box-shadow: rgba(0, 0, 0, 0.098) 0px 2px 4px, rgba(0, 0, 0, 0.098) 0px 0px 3px;
          /* transition */
          -webkit-transition: all 0.20s ease-out;
          transition: all 0.20s ease-out;
          display: block;
          box-sizing: border-box;
        }

        .dragging {
          -webkit-transition: none;
          transition: none;
          cursor: move !important;
        }

        swipe-action {
          height: 100%;
        }

        .left-action {

        }

        .right-action {

        }

        .up-action {

        }

        .down-action {

        }

        .action-icon {
          position: absolute;          
          padding: 8px;
          width: 32px;
          height: 32px;
        }

        .action-icon.align-left {
          left: 0;
          top: 50%;
          transform: translateY(-50%);
        }

        .action-icon.align-right {
          top: 50%;
          transform: translateY(-50%);
          right: 0;
        }

        .action-icon.align-top {
          top: 0;
          left: 50%;
          transform: translateX(-50%);
        }

        .action-icon.align-bottom {
          bottom: 0;
          left: 50%;
          transform: translateX(-50%);
        }
    </style>

    <template>
      <swipe-action id="swipeAction" gesture-disabled="[[!swipeable]]">
        <content></content>
        <div swipe-left-action disabled$="[[!rightIcon]]" on-tap="onActionTaped" class="right-action" swipe-size="48" swipe-rubber-band="60">
          <at-carbon-icon-color icon="[[rightIcon]]" color="[[rightIconColor]]" class="action-icon align-right"></at-carbon-icon-color>
        </div>
        <div swipe-right-action disabled$="[[!leftIcon]]" on-tap="onActionTaped" class="left-action" swipe-size="48" swipe-rubber-band="60">
          <at-carbon-icon-color icon="[[leftIcon]]" color="[[leftIconColor]]" class="action-icon align-left"></at-carbon-icon-color>
        </div>

        <div swipe-up-action disabled$="[[!bottomIcon]]" on-tap="onActionTaped" class="up-action" swipe-size="48" swipe-rubber-band="60">
          <at-carbon-icon-color icon="[[bottomIcon]]" color="[[bottomIconColor]]" class="action-icon align-bottom"></at-carbon-icon-color>
        </div>

        <div swipe-down-action disabled$="[[!topIcon]]" on-tap="onActionTaped" class="down-action" swipe-size="48" swipe-rubber-band="60">
          <at-carbon-icon-color icon="[[topIcon]]" color="[[topIconColor]]" class="action-icon align-top"></at-carbon-icon-color>
        </div>
      </swipe-action>
    </template>
</dom-module>
<script>
  Polymer({
      is: "at-core-card",
      /**
       * If true, the card can be swiped.
       *
       * @attribute swipeable
       * @type boolean
       * @default false
       */

      properties: {
        swipeable: {
          type: Boolean,
          observer: 'swipeableChanged',
          value: false
        },

        /** 
         * now:icon string for action on the left
         */
        leftIcon: {
          type: String,
          value: ""
        },

        leftIconColor: {
          type: String,
          value: "white"
        },

        /** 
         * now:icon string for action on the right
         */
        rightIcon: {
          type: String,
          value: ""
        },

        rightIconColor: {
          type: String,
          value: "white"
        },

        /** 
         * now:icon string for action on the top
         */
        topIcon: {
          type: String,
          value: ""
        },

        topIconColor: {
          type: String,
          value: "white"
        },

        /** 
         * now:icon string for action on the bottom
         */
        bottomIcon: {
          type: String,
          value: ""
        },

        bottomIconColor: {
          type: String,
          value: "white"
        },

        colorLeft: {
          type: String,
          value: "",
          observer: "_colorLeftChanged"
        },
        
        colorRight: {
          type: String,
          value: "",
          observer: "_colorRightChanged"
        },

        colorTop: {
          type: String,
          value: "",
          observer: "_colorTopChanged"
        },
        
        colorBottom: {
          type: String,
          value: "",
          observer: "_colorBottomChanged"
        },


        removing: {
          type: Boolean,
          value: true
        },
        noCurve: {
          type: Boolean,
          value: true
        },
        sort: {
          type: String,
          value: ""
          },
        offsetRatio: {
          type: Number,
          value: 0.2
        },
        widthRatio: {
          type: Number,
          value: 1.2
        }
      },
      listeners: {
        // track: 'track'
      },

      onActionTaped: function (event) {
        this.$.swipeAction.reset(true);
      },

      ready: function () {

        this.setScrollDirection('y');

        if(!this.transitionEndListener)
        {
          //this.setAttribute('touch-action', 'pan-y');
          //this.setAttribute('touch-action', 'none');
          this.transitionEndListener = this.transitionEnd.bind(this);
        }
      },

      attached: function () {
        // *ij* following code sets card size to be the size of the content
        // this can not be done automatically since 
        // 1. swipe-action has position relative; height: 100%
        // 2. all swipe actions have position: absolute; height: 100%
        // 3. #swipeTarget has position: absolute; height: 100%
        // So, we get the first child of swipeTarget, calculate its bounding client rect
        // and set width and height of at-core-card to that of swipeTarget's client rect
        // width and height
        var firstChild = this.$.swipeAction.$.swipeTarget.children[0];
        var fcBoundingRect = firstChild.getBoundingClientRect();

        this.style.width = fcBoundingRect.width + 'px';
        this.style.height = fcBoundingRect.height + 'px';
      },

      _colorLeftChanged: function (newValue, oldValue) {
        var swipeRightAction = this.$.swipeAction.querySelector('div[swipe-right-action]');
        if(swipeRightAction) {
          swipeRightAction.style['background-color'] = newValue;
        }
      },

      _colorRightChanged: function (newValue, oldValue) {
        var swipeLeftAction = this.$.swipeAction.querySelector('div[swipe-left-action]');
        if (swipeLeftAction) {
          swipeLeftAction.style['background-color'] = newValue;
        }
      },

      _colorTopChanged: function (newValue, oldValue) {
        var swipeBottomAction = this.$.swipeAction.querySelector('div[swipe-down-action]');
        if (swipeBottomAction) {
          swipeBottomAction.style['background-color'] = newValue;
        }
      },

      _colorBottomChanged: function (newValue, oldValue) {
        var swipeTopAction = this.$.swipeAction.querySelector('div[swipe-up-action]');
        if (swipeTopAction) {
          swipeTopAction.style['background-color'] = newValue;
        }
      },

      leftView: function () {
          if (this.removing) {
              this.removeListeners();
          }
      },
      addListeners: function () {
          // this.addEventListener('webkitTransitionEnd', this.transitionEndListener);
          // this.addEventListener('transitionend', this.transitionEndListener);
      },
      removeListeners: function () {
          // this.removeEventListener('webkitTransitionEnd', this.transitionEndListener);
          // this.removeEventListener('transitionend', this.transitionEndListener);
      },
      swipeableChanged: function () {

          if(!this.transitionEndListener)
          {
              this.transitionEndListener = this.transitionEnd.bind(this);
          }

          if (this.swipeable) {
              this.addListeners();
          } else {
              this.removeListeners();
          }
      },
      swipe: function (x) {
          var s = this.style;
          var d = x > 0 ? 1 : -1;
          var w = this.w * this.widthRatio;
          var x1 = Math.max(0, Math.abs(x) - this.w * this.offsetRatio);
          var r = Math.max(0, (w - x1) / w);
          if (x1 > w) x1 = w - 1; // avoid overflow when swiping to far
          var y = w - Math.sqrt(w * w - x1 * x1);
          //console.log("d:" + d + ", w " + w + ", x1 " + x1 + ", r " + r + ", y " + y);
          if (isNaN(y)) debugger;
          var deg = (1 - r) * d * 60; //90
          s.opacity = r;
          var translate = 'translate3d(' + x + 'px,' + (this.noCurve ? 0 : y) + 'px,0)';
          var rotate = 'rotate(' + deg + 'deg)';
          s.webkitTransform = s.mozTransform = s.msTransform = s.transform = translate + (this.noCurve ? '' : ' ' + rotate);
          //console.log(translate + (this.noCurve ? '' : ' ' + rotate));
      },

      track: function (e) {

        switch (e.detail.state) {

          case "track":
            if (this.swipeable) {

              if (!this._active) {  // start is sometimes(?) not fired, so we emulate missing start for now
                this._active = true;
                this._mode = "";
                this.w = this.offsetWidth;
                this.classList.add('dragging');
                this.style.touchAction = "none";
              }

              var r = e.detail;
              //console.log("x:" + r.x + ", dx:" + r.dx + ", ddx:" + r.ddx + ", dy: " + r.dy + " mode: " + this._mode);


              // the initial direction decides if it should be a swipe or move action
              if (this._mode == "") {
                if (Math.abs(r.dy) > 10) this._mode = "scroll";
                if (Math.abs(r.dx) > 10) this._mode = "swipe";
              }

              // when scrolling the card will not be swiped
              if (this._mode == "swipe") {
                this.swipe(e.detail.dx);
              } else {
                this.swipe(0);
              }

              // disable default scroll
              if (this._mode == "swipe") {
                e.returnValue = false;
                e.cancelBubble = true;
                  e.preventDefault();
                  e.stopPropagation();

                return false;
              }
            }
            break;

          case "start":
            if (this.swipeable) {
              this._active = true;
              this._mode = "";
              this.w = this.offsetWidth;
              this.classList.add('dragging');
              this.style.touchAction = "none";
            }
            break;

          case "end":
            if (this.swipeable) {
              this._active = false;
              this.style.touchAction = "pan-y";
              this.swipeEnd(Math.abs(e.detail.dx) > this.w / 2 && Math.abs(e.detail.dx)> 0, e.detail.dx > 0);
            }
            break;
        }
      },

      swipeEnd: function (away, dir) {
          //console.log("at-core-card swipeEnd");
          this.classList.remove('dragging');
          this.away = away;
          if (away) {
              this._fired = false;
              this.direction = dir ? "right" : "left";
              var w = this.w * this.widthRatio;
              this.swipe(dir ? w : -w);

              // on iphone transitionEnd is sometimes(?) not fired, so ensure here that event is triggered in that case as well
              this.async(function () {
                if (!this._fired) {
                  //console.log("at-core-card fire swipeEnd");
                  this._fired = true;
                  this.fire('at-core-card-swipe-away', { id: this.id, dir: this.direction });
                }
              },100);

          } else {
              this.swipe(0);
          }
      },
      transitionEnd: function (e) {
        console.log("at-core-card transitionEnd");
          if (this.away) {
            this.removing = true;
            if (!this._fired) {
              this._fired = true;
              //console.log("at-core-card fire transitionEnd");
              this.fire('at-core-card-swipe-away', { id: this.id, dir: this.direction });
            }
          }
      }
  });
</script>
